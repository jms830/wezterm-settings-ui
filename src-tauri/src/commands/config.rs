// Config commands - Tauri command handlers for config operations

use crate::config::{load_config_with_metadata, ConfigLoadResult};
use crate::models::AppearanceConfig;

/// Tauri command: Load the WezTerm configuration
/// Returns the parsed config along with metadata about the parse operation
#[tauri::command]
pub fn load_wezterm_config() -> Result<ConfigLoadResult, String> {
    load_config_with_metadata(None).map_err(|e| e.to_string())
}

/// Tauri command: Get the default configuration values
#[tauri::command]
pub fn get_default_config() -> AppearanceConfig {
    AppearanceConfig::default()
}

/// Tauri command: Save the configuration to disk
/// For now, this saves as a structured format that can be converted to Lua
#[tauri::command]
pub fn save_wezterm_config(config: AppearanceConfig) -> Result<SaveConfigResult, String> {
    use crate::config::get_wezterm_config_dir;
    
    let config_dir = get_wezterm_config_dir()?;
    let config_file = config_dir.join("wezterm.lua");
    
    // Generate Lua config content
    let lua_content = generate_lua_config(&config);
    
    // Backup existing config if present
    let backup_path = if config_file.exists() {
        let backup_name = format!(
            "wezterm.lua.backup.{}",
            chrono::Local::now().format("%Y%m%d_%H%M%S")
        );
        let backup_path = config_dir.join(&backup_name);
        std::fs::copy(&config_file, &backup_path)
            .map_err(|e| format!("Failed to create backup: {}", e))?;
        Some(backup_path.to_string_lossy().to_string())
    } else {
        None
    };
    
    // Write the new config
    std::fs::write(&config_file, &lua_content)
        .map_err(|e| format!("Failed to write config: {}", e))?;
    
    Ok(SaveConfigResult {
        success: true,
        config_path: config_file.to_string_lossy().to_string(),
        backup_path,
    })
}

#[derive(Debug, Clone, serde::Serialize)]
pub struct SaveConfigResult {
    pub success: bool,
    pub config_path: String,
    pub backup_path: Option<String>,
}

/// Generate a WezTerm Lua configuration file from the config struct
fn generate_lua_config(config: &AppearanceConfig) -> String {
    let mut lua = String::new();
    
    lua.push_str("-- WezTerm configuration\n");
    lua.push_str("-- Generated by WezTerm Settings GUI\n\n");
    lua.push_str("local wezterm = require 'wezterm'\n");
    lua.push_str("local config = wezterm.config_builder()\n\n");
    
    // Font settings
    lua.push_str("-- Font settings\n");
    lua.push_str(&format!(
        "config.font = wezterm.font('{}')\n",
        config.fonts.family
    ));
    lua.push_str(&format!("config.font_size = {}\n", config.fonts.size));
    if let Some(ref weight) = config.fonts.weight {
        lua.push_str(&format!("-- Font weight: {:?}\n", weight));
    }
    lua.push('\n');
    
    // Window settings
    lua.push_str("-- Window settings\n");
    lua.push_str(&format!(
        "config.window_background_opacity = {}\n",
        config.window.window_background_opacity
    ));
    lua.push_str(&format!(
        "config.window_decorations = '{}'\n",
        format_window_decorations(&config.window.window_decorations)
    ));
    lua.push_str(&format!(
        "config.enable_tab_bar = {}\n",
        config.window.enable_tab_bar
    ));
    lua.push_str(&format!(
        "config.hide_tab_bar_if_only_one_tab = {}\n",
        config.window.hide_tab_bar_if_only_one_tab
    ));
    lua.push_str(&format!(
        "config.use_fancy_tab_bar = {}\n",
        config.window.use_fancy_tab_bar
    ));
    lua.push_str(&format!(
        "config.tab_max_width = {}\n",
        config.window.tab_max_width
    ));
    lua.push_str(&format!(
        "config.show_tab_index_in_tab_bar = {}\n",
        config.window.show_tab_index_in_tab_bar
    ));
    
    // Window padding
    lua.push_str(&format!(
        "config.window_padding = {{\n  left = {},\n  right = {},\n  top = {},\n  bottom = {},\n}}\n",
        config.window.window_padding.left,
        config.window.window_padding.right,
        config.window.window_padding.top,
        config.window.window_padding.bottom
    ));
    
    // Window close confirmation
    lua.push_str(&format!(
        "config.window_close_confirmation = '{}'\n",
        format_close_confirmation(&config.window.window_close_confirmation)
    ));
    lua.push('\n');
    
    // Cursor settings
    lua.push_str("-- Cursor settings\n");
    lua.push_str(&format!(
        "config.default_cursor_style = '{}'\n",
        format_cursor_style(&config.cursor.default_cursor_style)
    ));
    lua.push_str(&format!(
        "config.cursor_blink_rate = {}\n",
        config.cursor.cursor_blink_rate
    ));
    lua.push_str(&format!(
        "config.cursor_blink_ease_in = '{}'\n",
        format_ease_function(&config.cursor.cursor_blink_ease_in)
    ));
    lua.push_str(&format!(
        "config.cursor_blink_ease_out = '{}'\n",
        format_ease_function(&config.cursor.cursor_blink_ease_out)
    ));
    lua.push_str(&format!(
        "config.animation_fps = {}\n",
        config.cursor.animation_fps
    ));
    lua.push('\n');
    
    // GPU settings
    lua.push_str("-- GPU settings\n");
    lua.push_str(&format!(
        "config.front_end = '{}'\n",
        format_front_end(&config.gpu.front_end)
    ));
    lua.push_str(&format!(
        "config.webgpu_power_preference = '{}'\n",
        format_power_preference(&config.gpu.webgpu_power_preference)
    ));
    lua.push_str(&format!("config.max_fps = {}\n", config.gpu.max_fps));
    lua.push('\n');
    
    // Color scheme
    lua.push_str("-- Color scheme\n");
    
    // If using a built-in color scheme, use that instead of custom colors
    if let Some(ref scheme_name) = config.color_scheme {
        lua.push_str(&format!("config.color_scheme = '{}'\n\n", scheme_name));
    } else {
        // Use custom colors
        lua.push_str("config.colors = {\n");
        lua.push_str(&format!("  foreground = '{}',\n", config.colors.foreground));
        lua.push_str(&format!("  background = '{}',\n", config.colors.background));
        lua.push_str(&format!("  cursor_bg = '{}',\n", config.colors.cursor_bg));
        lua.push_str(&format!("  cursor_border = '{}',\n", config.colors.cursor_border));
        lua.push_str(&format!("  cursor_fg = '{}',\n", config.colors.cursor_fg));
        lua.push_str(&format!("  selection_bg = '{}',\n", config.colors.selection_bg));
        lua.push_str(&format!("  selection_fg = '{}',\n", config.colors.selection_fg));
        
        // ANSI colors
        lua.push_str("  ansi = {\n");
        for color in &config.colors.ansi {
            lua.push_str(&format!("    '{}',\n", color));
        }
        lua.push_str("  },\n");
        
        // Bright colors
        lua.push_str("  brights = {\n");
        for color in &config.colors.brights {
            lua.push_str(&format!("    '{}',\n", color));
        }
        lua.push_str("  },\n");
        
        // Tab bar colors
        lua.push_str("  tab_bar = {\n");
        lua.push_str(&format!("    background = '{}',\n", config.colors.tab_bar.background));
        lua.push_str(&format_tab_colors("    active_tab", &config.colors.tab_bar.active_tab));
        lua.push_str(&format_tab_colors("    inactive_tab", &config.colors.tab_bar.inactive_tab));
        lua.push_str(&format_tab_colors("    inactive_tab_hover", &config.colors.tab_bar.inactive_tab_hover));
        lua.push_str(&format_tab_colors("    new_tab", &config.colors.tab_bar.new_tab));
        lua.push_str(&format_tab_colors("    new_tab_hover", &config.colors.tab_bar.new_tab_hover));
        lua.push_str("  },\n");
        
        lua.push_str("}\n\n");
    }
    
    // Backdrop/Background Image settings
    if config.backdrop.enabled && !config.backdrop.images.is_empty() {
        lua.push_str("-- Background image settings\n");
        
        // If random_on_start or multiple images, generate Lua code to pick randomly
        if config.backdrop.random_on_start && config.backdrop.images.len() > 1 {
            lua.push_str("local backdrops = {\n");
            for image in &config.backdrop.images {
                // Escape backslashes for Windows paths
                let escaped_path = image.replace('\\', "\\\\");
                lua.push_str(&format!("  '{}',\n", escaped_path));
            }
            lua.push_str("}\n");
            lua.push_str("config.window_background_image = backdrops[math.random(#backdrops)]\n");
        } else {
            // Use the current image or first image
            let image_path = if config.backdrop.current_index < config.backdrop.images.len() {
                &config.backdrop.images[config.backdrop.current_index]
            } else {
                &config.backdrop.images[0]
            };
            let escaped_path = image_path.replace('\\', "\\\\");
            lua.push_str(&format!("config.window_background_image = '{}'\n", escaped_path));
        }
        
        // Background image HSB for overlay effect (using overlay_opacity to control brightness)
        lua.push_str(&format!(
            "config.window_background_image_hsb = {{\n  hue = 1.0,\n  saturation = 1.0,\n  brightness = {},\n}}\n",
            1.0 - config.backdrop.overlay_opacity + 0.04  // Convert overlay opacity to brightness
        ));
        
        // Set the text background opacity for the focus color effect
        lua.push_str(&format!(
            "config.text_background_opacity = {}\n",
            config.backdrop.overlay_opacity
        ));
        
        lua.push('\n');
    }
    
    // General settings
    lua.push_str("-- General settings\n");
    lua.push_str(&format!(
        "config.automatically_reload_config = {}\n",
        config.general.automatically_reload_config
    ));
    lua.push_str(&format!(
        "config.scrollback_lines = {}\n",
        config.general.scrollback_lines
    ));
    lua.push_str(&format!(
        "config.initial_rows = {}\n",
        config.general.initial_rows
    ));
    lua.push_str(&format!(
        "config.initial_cols = {}\n",
        config.general.initial_cols
    ));
    lua.push_str(&format!(
        "config.exit_behavior = '{}'\n",
        format_exit_behavior(&config.general.exit_behavior)
    ));
    lua.push_str(&format!(
        "config.audible_bell = '{}'\n",
        format_audible_bell(&config.general.audible_bell)
    ));
    lua.push_str(&format!(
        "config.enable_scroll_bar = {}\n",
        config.general.enable_scroll_bar
    ));
    lua.push_str(&format!(
        "config.switch_to_last_active_tab_when_closing_tab = {}\n",
        config.general.switch_to_last_active_tab_when_closing_tab
    ));
    lua.push_str(&format!(
        "config.adjust_window_size_when_changing_font_size = {}\n",
        config.general.adjust_window_size_when_changing_font_size
    ));
    lua.push('\n');
    
    // Command palette settings
    lua.push_str("-- Command palette settings\n");
    lua.push_str("config.command_palette_fg_color = '");
    lua.push_str(&config.command_palette.fg_color);
    lua.push_str("'\n");
    lua.push_str("config.command_palette_bg_color = '");
    lua.push_str(&config.command_palette.bg_color);
    lua.push_str("'\n");
    lua.push_str(&format!(
        "config.command_palette_font_size = {}\n",
        config.command_palette.font_size
    ));
    lua.push('\n');
    
    // Visual bell settings
    lua.push_str("-- Visual bell settings\n");
    lua.push_str("config.visual_bell = {\n");
    lua.push_str(&format!(
        "  fade_in_duration_ms = {},\n",
        config.visual_bell.fade_in_duration_ms
    ));
    lua.push_str(&format!(
        "  fade_out_duration_ms = {},\n",
        config.visual_bell.fade_out_duration_ms
    ));
    lua.push_str(&format!(
        "  fade_in_function = '{}',\n",
        format_ease_function(&config.visual_bell.fade_in_function)
    ));
    lua.push_str(&format!(
        "  fade_out_function = '{}',\n",
        format_ease_function(&config.visual_bell.fade_out_function)
    ));
    lua.push_str(&format!(
        "  target = '{}',\n",
        config.visual_bell.target
    ));
    lua.push_str("}\n\n");
    
    // Generate keybindings
    lua.push_str(&generate_keybindings_lua(&config.keybindings));
    
    lua.push_str("return config\n");
    
    lua
}

fn format_tab_colors(name: &str, colors: &crate::models::TabColors) -> String {
    let mut s = format!("{} = {{\n", name);
    s.push_str(&format!("      bg_color = '{}',\n", colors.bg_color));
    s.push_str(&format!("      fg_color = '{}',\n", colors.fg_color));
    if let Some(italic) = colors.italic {
        s.push_str(&format!("      italic = {},\n", italic));
    }
    s.push_str("    },\n");
    s
}

fn format_window_decorations(d: &crate::models::WindowDecorations) -> &'static str {
    use crate::models::WindowDecorations::*;
    match d {
        Full => "FULL",
        Resize => "RESIZE",
        None => "NONE",
        Title => "TITLE",
        IntegratedButtonsResize => "INTEGRATED_BUTTONS|RESIZE",
    }
}

fn format_close_confirmation(c: &crate::models::CloseConfirmation) -> &'static str {
    use crate::models::CloseConfirmation::*;
    match c {
        AlwaysPrompt => "AlwaysPrompt",
        NeverPrompt => "NeverPrompt",
    }
}

fn format_cursor_style(s: &crate::models::CursorStyle) -> &'static str {
    use crate::models::CursorStyle::*;
    match s {
        SteadyBlock => "SteadyBlock",
        BlinkingBlock => "BlinkingBlock",
        SteadyUnderline => "SteadyUnderline",
        BlinkingUnderline => "BlinkingUnderline",
        SteadyBar => "SteadyBar",
        BlinkingBar => "BlinkingBar",
    }
}

fn format_ease_function(e: &crate::models::EaseFunction) -> &'static str {
    use crate::models::EaseFunction::*;
    match e {
        Linear => "Linear",
        EaseIn => "EaseIn",
        EaseOut => "EaseOut",
        EaseInOut => "EaseInOut",
        Constant => "Constant",
    }
}

fn format_front_end(f: &crate::models::FrontEnd) -> &'static str {
    use crate::models::FrontEnd::*;
    match f {
        WebGpu => "WebGpu",
        OpenGL => "OpenGL",
        Software => "Software",
    }
}

fn format_power_preference(p: &crate::models::PowerPreference) -> &'static str {
    use crate::models::PowerPreference::*;
    match p {
        LowPower => "LowPower",
        HighPerformance => "HighPerformance",
    }
}

fn format_exit_behavior(e: &crate::models::ExitBehavior) -> &'static str {
    use crate::models::ExitBehavior::*;
    match e {
        Close => "Close",
        CloseOnCleanExit => "CloseOnCleanExit",
        Hold => "Hold",
    }
}

fn format_audible_bell(a: &crate::models::AudibleBell) -> &'static str {
    use crate::models::AudibleBell::*;
    match a {
        SystemBeep => "SystemBeep",
        Disabled => "Disabled",
    }
}

/// Generate complete keybindings Lua code
fn generate_keybindings_lua(kb: &crate::models::KeyBindingsConfig) -> String {
    use crate::models::KeyBinding;
    
    let mut lua = String::new();
    
    lua.push_str("-- ============================================================================\n");
    lua.push_str("-- Keybindings Configuration\n");
    lua.push_str("-- Generated by WezTerm Settings TUI\n");
    lua.push_str("-- ============================================================================\n\n");
    
    // Disable default keybindings if configured
    if kb.disable_defaults {
        lua.push_str("config.disable_default_key_bindings = true\n\n");
    }
    
    // Leader key
    if kb.leader.enabled {
        lua.push_str(&format!(
            "config.leader = {{ key = '{}', mods = '{}', timeout_milliseconds = {} }}\n\n",
            kb.leader.key, kb.leader.mods, kb.leader.timeout_ms
        ));
    }
    
    // Helper to generate a simple keybinding
    fn simple_key(kb: &KeyBinding, action: &str) -> Option<String> {
        if kb.enabled {
            Some(format!(
                "   {{ key = '{}', mods = '{}', action = {} }},\n",
                kb.key, kb.mods, action
            ))
        } else {
            None
        }
    }
    
    // Start keys table
    lua.push_str("config.keys = {\n");
    
    // -- Misc/useful bindings --
    lua.push_str("   -- misc/useful --\n");
    if let Some(s) = simple_key(&kb.misc.copy_mode, "'ActivateCopyMode'") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.misc.command_palette, "act.ActivateCommandPalette") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.misc.command_palette_alt, "act.ActivateCommandPalette") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.misc.show_launcher, "act.ShowLauncher") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.misc.show_tab_launcher, "act.ShowLauncherArgs({ flags = 'FUZZY|TABS' })") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.misc.show_workspace_launcher, "act.ShowLauncherArgs({ flags = 'FUZZY|WORKSPACES' })") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.misc.toggle_fullscreen, "act.ToggleFullScreen") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.misc.show_debug_overlay, "act.ShowDebugOverlay") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.misc.search, "act.Search({ CaseInSensitiveString = '' })") { lua.push_str(&s); }
    
    // Quick select URL (complex action)
    if kb.misc.quick_select_url.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = wezterm.action.QuickSelectArgs({{
         label = 'open url',
         patterns = {{
            '\\((https?://\\S+)\\)',
            '\\[(https?://\\S+)\\]',
            '\\{{(https?://\\S+)\\}}',
            '<(https?://\\S+)>',
            '\\bhttps?://\\S+[)/a-zA-Z0-9-]+'
         }},
         action = wezterm.action_callback(function(window, pane)
            local url = window:get_selection_text_for_pane(pane)
            wezterm.log_info('opening: ' .. url)
            wezterm.open_with(url)
         end),
      }}),
   }},
"#,
            kb.misc.quick_select_url.key, kb.misc.quick_select_url.mods
        ));
    }
    lua.push('\n');
    
    // -- Cursor movement --
    lua.push_str("   -- cursor movement --\n");
    if let Some(s) = simple_key(&kb.cursor.home, "act.SendString '\\u{1b}OH'") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.cursor.end, "act.SendString '\\u{1b}OF'") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.cursor.delete_line, "act.SendString '\\u{15}'") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.cursor.newline, "act.SendString('\\n')") { lua.push_str(&s); }
    lua.push('\n');
    
    // -- Copy/paste --
    lua.push_str("   -- copy/paste --\n");
    if let Some(s) = simple_key(&kb.copy_paste.copy, "act.CopyTo('Clipboard')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.copy_paste.paste, "act.PasteFrom('Clipboard')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.copy_paste.copy_simple, "act.CopyTo('Clipboard')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.copy_paste.paste_simple, "act.PasteFrom('Clipboard')") { lua.push_str(&s); }
    lua.push('\n');
    
    // -- Tabs --
    lua.push_str("   -- tabs: spawn+close --\n");
    if let Some(s) = simple_key(&kb.tabs.spawn_tab, "act.SpawnTab('DefaultDomain')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.tabs.spawn_tab_wsl, "act.SpawnTab({ DomainName = 'wsl:ubuntu-fish' })") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.tabs.close_tab, "act.CloseCurrentTab({ confirm = false })") { lua.push_str(&s); }
    lua.push_str("   -- tabs: navigation --\n");
    if let Some(s) = simple_key(&kb.tabs.prev_tab, "act.ActivateTabRelative(-1)") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.tabs.next_tab, "act.ActivateTabRelative(1)") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.tabs.move_tab_back, "act.MoveTabRelative(-1)") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.tabs.move_tab_forward, "act.MoveTabRelative(1)") { lua.push_str(&s); }
    
    // Rename tab - Use event pattern for compatibility with custom tab-title handlers
    lua.push_str("   -- tab: title --\n");
    if kb.tabs.rename_tab.enabled {
        lua.push_str(&format!(
            "   {{ key = '{}', mods = '{}', action = act.EmitEvent('Rename Current Tab') }},\n",
            kb.tabs.rename_tab.key, kb.tabs.rename_tab.mods
        ));
    }
    if let Some(s) = simple_key(&kb.tabs.manual_update_title, "act.EmitEvent('Rename Current Tab')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.tabs.reset_title, "act.EmitEvent('Reset Tab Title')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.tabs.toggle_tab_bar, "act.EmitEvent('tabs.toggle-tab-bar')") { lua.push_str(&s); }
    lua.push('\n');
    
    // -- Window --
    lua.push_str("   -- window --\n");
    if let Some(s) = simple_key(&kb.windows.spawn_window, "act.SpawnWindow") { lua.push_str(&s); }
    
    // Window zoom (complex actions)
    if kb.windows.shrink_window.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = wezterm.action_callback(function(window, _pane)
         local dimensions = window:get_dimensions()
         if dimensions.is_full_screen then return end
         local new_width = dimensions.pixel_width - 50
         local new_height = dimensions.pixel_height - 50
         window:set_inner_size(new_width, new_height)
      end)
   }},
"#,
            kb.windows.shrink_window.key, kb.windows.shrink_window.mods
        ));
    }
    if kb.windows.grow_window.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = wezterm.action_callback(function(window, _pane)
         local dimensions = window:get_dimensions()
         if dimensions.is_full_screen then return end
         local new_width = dimensions.pixel_width + 50
         local new_height = dimensions.pixel_height + 50
         window:set_inner_size(new_width, new_height)
      end)
   }},
"#,
            kb.windows.grow_window.key, kb.windows.grow_window.mods
        ));
    }
    if kb.windows.maximize_window.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = wezterm.action_callback(function(window, _pane)
         window:maximize()
      end)
   }},
"#,
            kb.windows.maximize_window.key, kb.windows.maximize_window.mods
        ));
    }
    lua.push('\n');
    
    // -- Backdrops --
    lua.push_str("   -- background controls --\n");
    if kb.backdrops.random.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = wezterm.action_callback(function(window, _pane)
         backdrops:random(window)
      end),
   }},
"#,
            kb.backdrops.random.key, kb.backdrops.random.mods
        ));
    }
    if kb.backdrops.cycle_back.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = wezterm.action_callback(function(window, _pane)
         backdrops:cycle_back(window)
      end),
   }},
"#,
            kb.backdrops.cycle_back.key, kb.backdrops.cycle_back.mods
        ));
    }
    if kb.backdrops.cycle_forward.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = wezterm.action_callback(function(window, _pane)
         backdrops:cycle_forward(window)
      end),
   }},
"#,
            kb.backdrops.cycle_forward.key, kb.backdrops.cycle_forward.mods
        ));
    }
    if kb.backdrops.select.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = act.InputSelector({{
         title = 'InputSelector: Select Background',
         choices = backdrops:choices(),
         fuzzy = true,
         fuzzy_description = 'Select Background: ',
         action = wezterm.action_callback(function(window, _pane, idx)
            if not idx then return end
            backdrops:set_img(window, tonumber(idx))
         end),
      }}),
   }},
"#,
            kb.backdrops.select.key, kb.backdrops.select.mods
        ));
    }
    if kb.backdrops.toggle_focus.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = wezterm.action_callback(function(window, _pane)
         backdrops:toggle_focus(window)
      end)
   }},
"#,
            kb.backdrops.toggle_focus.key, kb.backdrops.toggle_focus.mods
        ));
    }
    lua.push('\n');
    
    // -- Panes --
    lua.push_str("   -- panes: split panes --\n");
    if let Some(s) = simple_key(&kb.panes.split_vertical, "act.SplitVertical({ domain = 'CurrentPaneDomain' })") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.split_horizontal, "act.SplitHorizontal({ domain = 'CurrentPaneDomain' })") { lua.push_str(&s); }
    lua.push_str("   -- panes: zoom+close pane --\n");
    if let Some(s) = simple_key(&kb.panes.toggle_zoom, "act.TogglePaneZoomState") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.close_pane, "act.CloseCurrentPane({ confirm = false })") { lua.push_str(&s); }
    lua.push_str("   -- panes: navigation --\n");
    if let Some(s) = simple_key(&kb.panes.nav_up, "act.ActivatePaneDirection('Up')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.nav_down, "act.ActivatePaneDirection('Down')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.nav_left, "act.ActivatePaneDirection('Left')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.nav_right, "act.ActivatePaneDirection('Right')") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.swap_pane, "act.PaneSelect({ alphabet = '1234567890', mode = 'SwapWithActiveKeepFocus' })") { lua.push_str(&s); }
    lua.push_str("   -- panes: scroll pane --\n");
    if let Some(s) = simple_key(&kb.panes.scroll_up, "act.ScrollByLine(-5)") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.scroll_down, "act.ScrollByLine(5)") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.page_up, "act.ScrollByPage(-0.75)") { lua.push_str(&s); }
    if let Some(s) = simple_key(&kb.panes.page_down, "act.ScrollByPage(0.75)") { lua.push_str(&s); }
    lua.push('\n');
    
    // -- Key tables --
    lua.push_str("   -- key-tables --\n");
    if kb.key_tables.resize_font_mode.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = act.ActivateKeyTable({{
         name = 'resize_font',
         one_shot = false,
         timeout_milliseconds = 1000,
      }}),
   }},
"#,
            kb.key_tables.resize_font_mode.key, kb.key_tables.resize_font_mode.mods
        ));
    }
    if kb.key_tables.resize_pane_mode.enabled {
        lua.push_str(&format!(
            r#"   {{
      key = '{}',
      mods = '{}',
      action = act.ActivateKeyTable({{
         name = 'resize_pane',
         one_shot = false,
         timeout_milliseconds = 1000,
      }}),
   }},
"#,
            kb.key_tables.resize_pane_mode.key, kb.key_tables.resize_pane_mode.mods
        ));
    }
    
    // Close keys table
    lua.push_str("}\n\n");
    
    // Key tables definitions
    lua.push_str("config.key_tables = {\n");
    lua.push_str("   resize_font = {\n");
    lua.push_str("      { key = 'k',      action = act.IncreaseFontSize },\n");
    lua.push_str("      { key = 'j',      action = act.DecreaseFontSize },\n");
    lua.push_str("      { key = 'r',      action = act.ResetFontSize },\n");
    lua.push_str("      { key = 'Escape', action = 'PopKeyTable' },\n");
    lua.push_str("      { key = 'q',      action = 'PopKeyTable' },\n");
    lua.push_str("   },\n");
    lua.push_str("   resize_pane = {\n");
    lua.push_str("      { key = 'k',      action = act.AdjustPaneSize({ 'Up', 1 }) },\n");
    lua.push_str("      { key = 'j',      action = act.AdjustPaneSize({ 'Down', 1 }) },\n");
    lua.push_str("      { key = 'h',      action = act.AdjustPaneSize({ 'Left', 1 }) },\n");
    lua.push_str("      { key = 'l',      action = act.AdjustPaneSize({ 'Right', 1 }) },\n");
    lua.push_str("      { key = 'Escape', action = 'PopKeyTable' },\n");
    lua.push_str("      { key = 'q',      action = 'PopKeyTable' },\n");
    lua.push_str("   },\n");
    lua.push_str("}\n\n");
    
    // Mouse bindings
    lua.push_str("config.mouse_bindings = {\n");
    if kb.mouse.ctrl_click_open_link {
        lua.push_str("   {\n");
        lua.push_str("      event = { Up = { streak = 1, button = 'Left' } },\n");
        lua.push_str("      mods = 'CTRL',\n");
        lua.push_str("      action = act.OpenLinkAtMouseCursor,\n");
        lua.push_str("   },\n");
    }
    if kb.mouse.right_click_command_palette {
        lua.push_str("   {\n");
        lua.push_str("      event = { Down = { streak = 1, button = 'Right' } },\n");
        lua.push_str("      mods = 'NONE',\n");
        lua.push_str("      action = act.ActivateCommandPalette,\n");
        lua.push_str("   },\n");
    }
    lua.push_str("}\n\n");
    
    // Custom command palette entries
    if kb.custom_commands.settings_tui || kb.custom_commands.rename_tab {
        lua.push_str("-- Add custom commands to command palette (Ctrl+Shift+P)\n");
        lua.push_str("wezterm.on('augment-command-palette', function(window, pane)\n");
        lua.push_str("   return {\n");
        
        if kb.custom_commands.settings_tui {
            lua.push_str("      {\n");
            lua.push_str("         brief = 'Settings-TUI',\n");
            lua.push_str("         icon = 'md_cog',\n");
            lua.push_str("         action = wezterm.action.SpawnCommandInNewWindow {\n");
            lua.push_str("            args = { 'wezterm-settings-tui' },\n");
            lua.push_str("         },\n");
            lua.push_str("      },\n");
        }
        
        if kb.custom_commands.rename_tab {
            lua.push_str("      {\n");
            lua.push_str("         brief = 'Rename Current Tab',\n");
            lua.push_str("         icon = 'md_rename_box',\n");
            lua.push_str("         action = wezterm.action.EmitEvent('Rename Current Tab'),\n");
            lua.push_str("      },\n");
            lua.push_str("      {\n");
            lua.push_str("         brief = 'Reset Tab Title',\n");
            lua.push_str("         icon = 'md_undo',\n");
            lua.push_str("         action = wezterm.action.EmitEvent('Reset Tab Title'),\n");
            lua.push_str("      },\n");
        }
        
        lua.push_str("   }\n");
        lua.push_str("end)\n\n");
    }
    
    // Generate event handlers for tab renaming
    // These are needed when using EmitEvent('Rename Current Tab') / EmitEvent('Reset Tab Title')
    if kb.tabs.rename_tab.enabled || kb.tabs.manual_update_title.enabled || kb.custom_commands.rename_tab {
        lua.push_str("-- ============================================================================\n");
        lua.push_str("-- Tab Title Event Handlers\n");
        lua.push_str("-- These events show in the command palette with human-readable names\n");
        lua.push_str("-- ============================================================================\n\n");
        
        lua.push_str("-- Track tab titles for persistence\n");
        lua.push_str("local tab_titles = {}\n\n");
        
        lua.push_str("-- Event: Rename Current Tab\n");
        lua.push_str("-- Opens a prompt to rename the current tab. Title persists until reset.\n");
        lua.push_str("wezterm.on('Rename Current Tab', function(window, pane)\n");
        lua.push_str("   window:perform_action(\n");
        lua.push_str("      wezterm.action.PromptInputLine({\n");
        lua.push_str("         description = wezterm.format({\n");
        lua.push_str("            { Foreground = { Color = '#FFFFFF' } },\n");
        lua.push_str("            { Text = 'Enter new tab name: ' },\n");
        lua.push_str("         }),\n");
        lua.push_str("         action = wezterm.action_callback(function(inner_window, inner_pane, line)\n");
        lua.push_str("            if line and line ~= '' then\n");
        lua.push_str("               local tab = inner_window:active_tab()\n");
        lua.push_str("               local id = tab:tab_id()\n");
        lua.push_str("               tab_titles[id] = { title = line, locked = true }\n");
        lua.push_str("               tab:set_title(line)\n");
        lua.push_str("            end\n");
        lua.push_str("         end),\n");
        lua.push_str("      }),\n");
        lua.push_str("      pane\n");
        lua.push_str("   )\n");
        lua.push_str("end)\n\n");
        
        lua.push_str("-- Event: Reset Tab Title\n");
        lua.push_str("-- Removes custom tab title and restores automatic naming.\n");
        lua.push_str("wezterm.on('Reset Tab Title', function(window, _pane)\n");
        lua.push_str("   local tab = window:active_tab()\n");
        lua.push_str("   local id = tab:tab_id()\n");
        lua.push_str("   tab_titles[id] = nil\n");
        lua.push_str("   tab:set_title('')  -- Empty string triggers automatic title\n");
        lua.push_str("end)\n\n");
    }
    
    lua
}
